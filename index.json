[{"content":"In the last blog, we talked about the Quantum Adiabatic Algorithm (QAA) and used it solve the MIS problem. Here, we will discuss the Quantum Approximation Optimization Algorithm (QAOA) which is popular algorithm in the gate based quantum computing. We will use QAOA to solve the same MIS problem that we tackled in the last blog.\nAlgorithm description In QAOA, we start with an eigenstate of the mixer hamiltonian. We then exponentiate and parameterize in $p$ steps by $p$ betas and gammas:\n$$\\lvert \\psi(\\boldsymbol{\\beta}, \\boldsymbol{\\gamma}) \\rangle = \\underbrace{U(\\boldsymbol{\\beta}) U(\\boldsymbol{\\gamma}) \\cdots U(\\boldsymbol{\\beta}) U(\\boldsymbol{\\gamma})}_{p \\ \\text{times}} \\lvert \\psi_0 \\rangle$$\nwhere betas and gammas are to be optimized with a classical opitimizer. Here $U(\\boldsymbol{\\beta}) = e^{-i \\boldsymbol{\\beta} H_M}$ and $U(\\boldsymbol{\\gamma}) = e^{-i \\boldsymbol{\\gamma} H_C}$. Remember $H_M$ and $H_C$ are the mixer and cost hamiltonian respectively. The idea here is that instead of having a continuous evolution, we evolve with one hamiltonian at a time $H_C$ or $H_M$ and repeat it for $p$ steps.\nComparing with QAA The figure below from ( Citation: Verdon,\u0026#32;Broughton \u0026amp; al.,\u0026#32; Verdon,\u0026#32; G.,\u0026#32; Broughton,\u0026#32; M.\u0026#32;\u0026amp;\u0026#32;Biamonte,\u0026#32; J. \u0026#32; (n.d.). \u0026#32; A quantum algorithm to train neural networks using low-depth circuits. ) , shows how the control function $u(t)$ is continuous slow varying function in QAA, while in QAOA, we have discretized control function so we evolve with $H_C$ and $H_M$ alternatively.\nThe discretized control function can be written as\n$$u_i = \\frac{\\beta_i}{\\gamma_i + \\beta_i} $$\nAt the begining, $H_M$ will be dominationg, so betas will be large and gammas will be small. This way, the control function will tend to the value of 1. In the end, gammas will increase making the control funciton to zero thereby dominating $H_C$.\nImplementation We build parameterized sequences in pulser to implement the alternating hamiltonians $H_M$ and $H_C$. Remember the expression for the global hamiltonian\n$$H_Q = \\sum_{i=1}^N \\frac{\\hbar\\Omega(t)}{2} \\sigma_i^x - \\sum_{i=1}^N \\frac{\\hbar \\delta(t)}{2} \\sigma_i^z+\\sum_{j \\lt i} \\frac{C_6}{|\\textbf{r}_i-\\textbf{r}_j|^{6}}n_i n_j $$\nWe can observe that the $H_M$ is defined when the laser is turned on and detuning is turned off i.e. $\\Omega \u0026gt; 0, \\delta = 0$. Therefore to implement a beta pulse for the mixer hamiltonian, we choose $\\Omega = 1, \\delta = 0$. In constrast, for the cost hamiltonian we choose $\\Omega = 0, \\delta = 1$. The parameters control the duration of pulses which will be optimized by the classical optimizer.\nPulses for $H_M$ and $H_C$ with random parameters for 2 alternating layers\nThe cost function which we aim to minimize remains the same that we used in QAA\n$$ C(x_1, x_2, \\dots x_N) = - \\sum_{i=1}^{N}x_i + U \\sum_{(i,j) \\in E} x_i x_j$$\nTo implement this cost for QAOA, we can represent it as follows\n$$ f(z) = -1^{T}x + Ux^{T}Ax $$\nwhere A is the adjacency matrix of the graph $G=(V,E)$, $U$ is the penalty coefficient and $x$ is a binary vector representing the nodes in the independent. We consider only the upper triangular matrix of A otherwise the cost function will count the node connections twice. We use the Nelder-Mead classical optimizer from scipy. Simulation results into the following historgram of counts.\nThe bitstring with maximum counts is 1010011 which is indeed the MIS for the given graph. The set of nodes is $\\{0, 2, 5, 6\\}$. The optimal parameters result into the following pulses.\nPulses for $H_M$ and $H_C$ with optimized parameters\nCompared to QAA, QAOA is not much effective. Although, increasing the number of layers can boost the probability of success, it comes at the cost of high depths.\nThe code to reproduce the figures can be found here. A more general tutorial is available in the Pulser\u0026rsquo;s docs ( Citation: Pasqal,\u0026#32; Pasqal,\u0026#32; P. \u0026#32; (n.d.). \u0026#32; QAOA and QAA to solve a QUBO problem. \u0026#32;Retrieved from\u0026#32; https://pulser.readthedocs.io/en/stable/tutorials/qubo.html ) .\nReferences Pasqal (n.d.) Pasqal,\u0026#32; P. \u0026#32; (n.d.). \u0026#32; QAOA and QAA to solve a QUBO problem. \u0026#32;Retrieved from\u0026#32; https://pulser.readthedocs.io/en/stable/tutorials/qubo.html Verdon,\u0026#32; Broughton\u0026#32;\u0026amp;\u0026#32;Biamonte (n.d.) Verdon,\u0026#32; G.,\u0026#32; Broughton,\u0026#32; M.\u0026#32;\u0026amp;\u0026#32;Biamonte,\u0026#32; J. \u0026#32; (n.d.). \u0026#32; A quantum algorithm to train neural networks using low-depth circuits. ","permalink":"https://gopal-dahale.github.io/ILearnQuantum/posts/mis/qaoa/","summary":"In the last blog, we talked about the Quantum Adiabatic Algorithm (QAA) and used it solve the MIS problem. Here, we will discuss the Quantum Approximation Optimization Algorithm (QAOA) which is popular algorithm in the gate based quantum computing. We will use QAOA to solve the same MIS problem that we tackled in the last blog.\nAlgorithm description In QAOA, we start with an eigenstate of the mixer hamiltonian. We then exponentiate and parameterize in $p$ steps by $p$ betas and gammas:","title":"QAOA to solve MIS"},{"content":"Recently, I participated in the The Blaise Pascal [re]Generative Quantum Challenge by Pasqal and got to learn about Pasqal\u0026rsquo;s neutral atom arrays and pulse-level programming as well as implementing quantum algorithms on an analog device. Here, I will share my learnings and in this blog particularly, we will solve the MIS problem with the quantum adiabatic algorithm using Pulser ( Citation: Henrique,\u0026#32;Grijalva \u0026amp; al.,\u0026#32; Henrique,\u0026#32; S.,\u0026#32; Grijalva,\u0026#32; S.,\u0026#32; Henriet,\u0026#32; L.,\u0026#32; Cornillot,\u0026#32; A.,\u0026#32; AJDNIK,\u0026#32; L.,\u0026#32; Karalekas,\u0026#32; P.\u0026#32;\u0026amp;\u0026#32;et al. \u0026#32; (n.d.). \u0026#32; pasqal-io/Pulser: Release v0.15.3. \u0026#32; Zenodo.\u0026#32;Retrieved from\u0026#32; https://github.com/pasqal-io/Pulser ) .\nMIS as QUBO An independent set (IS) of a graph is defined as a subset $S$ of nodes such that no two nodes in $S$ are adjacent. An IS is maximal if no node can be added to $S$ without violating IS. A maximum independent set (MIS) is one of maximum cardinality.\nMIS can be represented as a QUBO problem. Every node of the graph $G = (V, E)$ is assigned with a binary variable $x_i$. If the $i^{th}$ vertex is present in the MIS then we assing $x_i = 1$ otherwise $x_i = 0$. The goal is to then minimize the below cost function\n$$ C(x_1, x_2, \\dots x_N) = - \\sum_{i=1}^{N}x_i + U \\sum_{(i,j) \\in E} x_i x_j \\tag{1} $$\nwhere $N$ is the number of nodes in $G$. Selecting a node that belongs to MIS decreases the value of $C$ (first term) but since we don\u0026rsquo;t want two adjacent nodes to be in the MIS, we add a positive penalization (second term) with a penalty coefficient $U \u0026gt; 0$.\nAnalog Quantum Computing The below expression represents the neutral atoms quantum computer globlal hamiltonian.\n$$H_Q = \\sum_{i=1}^N \\frac{\\hbar\\Omega(t)}{2} \\sigma_i^x - \\sum_{i=1}^N \\frac{\\hbar \\delta(t)}{2} \\sigma_i^z+\\sum_{j \\lt i} \\frac{C_6}{|\\textbf{r}_i-\\textbf{r}_j|^{6}}n_i n_j \\tag{2} $$\nWe have three contributions here.\nThe first contribution is controlled by the amplitude of the laser $\\Omega$ (Rabi frequency). The second term is controlled by the detuning $\\delta$ of the laser beam. The third term models the dipole-dipole interactions between pairs of atom. The combined expression of the last two terms is similar to the cost function $C$. The idea is to encode the cost function in $H_Q$ and then find the ground state of the global hamiltonian by continuous manipulation of $\\Omega(t)$ and $\\delta(t)$.\nBut what about the first term and how will we find the ground state of $H_Q$? The next section answers these questions by describing the analog quantum algorithms framework.\nAdiabatic evolution In analog quantum computing, we consider a hamiltonian of the following form:\n$$ H(t) = u(t) H_M + (1 - u(t)) H_C $$\nwhere $H_C$ is the \u0026ldquo;cost\u0026rdquo; hamiltonian which encodes the optimization task that we are trying to solve. Here it is the MIS problem. $H_M$ is the \u0026ldquo;mixer\u0026rdquo; hamiltonian which encodes the quantum mixing (eg. a uniform transverse field on qubits) and $u(t) \\in [0,1]$ is the control function.\nThe approach is to start with a hamiltonian $H_M$ whose ground state can be found easily. The system is set in the ground sate of $H_M$ at $t = 0, u(0) = 1$ and then slowly evolved, converging to the ground state of $H_C$ ($t = t_F, u(t_F) = 1$). At any time through the evolution, we will have a hamiltonian that is a linear combination of $H_M$ and $H_C$ controlled by $u(t)$.\nWe encode $H_C$ in the last two terms of $H_Q$ i.e. the problem hamiltonian and then $H_M$ will become the first term of $H_Q$ representing the mixer hamiltonian.\nQuantum Adiabatic Theorem Consider a time-varying Hamiltonian, $H(t)$, which is initially $H_M$ at $t = 0$, and subsequently $H_C$ at some later time, $t = t_F$ , then if the system is initially in the ground-state of $H_M$, and as long as the time-evolution of the Hamiltonian is sufficiently slow, the state is likely to remain in the ground-state throughout the evolution, therefore being in the ground-state of $H_C$ at $t = t_F$ ( Citation: Herbert,\u0026#32; Herbert,\u0026#32; S. \u0026#32; (n.d.). \u0026#32; Quantum Computing (CST Part II) Lecture 15: Adiabatic Quantum Computing. \u0026#32;Retrieved from\u0026#32; https://www.cl.cam.ac.uk/teaching/1920/QuantComp/Quantum_Computing_Lecture_15.pdf ) .\nBut how slow is sufficiently slow? Well, the proof ( Citation: Childs,\u0026#32; Childs,\u0026#32; A. \u0026#32; (n.d.). \u0026#32; Quantum algorithms (CO 781, Winter 2008): LECTURE 18: The quantum adiabatic theorem. \u0026#32;Retrieved from\u0026#32; https://www.cs.umd.edu/~amchilds/teaching/w08/l18.pdf ) is complex, however we will see it in pratice that if we do not give sufficient time for the evolution of $H(t)$, the probability of finding the ground state or in our case finding the MIS turns out to near zero.\nProblem Formulation We take a small graph with 7 nodes depicted below\nQuantum Adiabatic Algorithm In the beginning, we want to be in ground state of $H_M$ so $\\delta (0) = 0$. Instead of the this we take $\\Omega(0)=0, \\delta(0)\u0026lt;0$. This will make the second term of (2) positive as $\\delta(0) \u0026lt; 0$. The idea is to prepare the initial state of the system in the first half of the evolution. After the first half, we will have a superpostition of states that reproduces an independent set of various sizes. In the second half, we turn off $\\Omega$ and turn on the detuning $\\delta$ ending with $\\Omega(0)=0, \\delta\u0026gt;0$. If this evolution is slow enough, we are supposed to obtain a superpostion of states that can produce a maximal independent set. This can be achieved with the following pulse\nNote the duration of pulse ($4 \\mu$s). Simulation results into the following historgram of counts.\nThe bitstring with maximum counts is 1010011 which is indeed the MIS for the given graph. The set of nodes is $\\{0, 2, 5, 6\\}$.\nEffect of time evolution on quality of MIS We test with different time durations ranging from $1 - 15 \\mu$s and observe the probability of successfully obtaining the MIS.\nAfter a certain point (~ $12 \\mu$s), we see that the success probability flattens out. This time duration is sufficiently large. A precise definition of sufficiently large can be found here ( Citation: Pesah,\u0026#32; Pesah,\u0026#32; A. \u0026#32; (n.d.). \u0026#32; Adiabatic Quantum Computing. \u0026#32;Retrieved from\u0026#32; https://arthurpesah.me/assets/pdf/introduction-quantum-annealing.pdf ) .\nThe code to reproduce the figures can be found here. A more general tutorial is available in the Pulser\u0026rsquo;s docs ( Citation: Pasqal,\u0026#32; Pasqal,\u0026#32; P. \u0026#32; (n.d.). \u0026#32; QAOA and QAA to solve a QUBO problem. \u0026#32;Retrieved from\u0026#32; https://pulser.readthedocs.io/en/stable/tutorials/qubo.html ) .\nReferences Henrique,\u0026#32; Grijalva,\u0026#32; Henriet,\u0026#32; Cornillot,\u0026#32; AJDNIK,\u0026#32; Karalekas\u0026#32;\u0026amp;\u0026#32;et al. (n.d.) Henrique,\u0026#32; S.,\u0026#32; Grijalva,\u0026#32; S.,\u0026#32; Henriet,\u0026#32; L.,\u0026#32; Cornillot,\u0026#32; A.,\u0026#32; AJDNIK,\u0026#32; L.,\u0026#32; Karalekas,\u0026#32; P.\u0026#32;\u0026amp;\u0026#32;et al. \u0026#32; (n.d.). \u0026#32; pasqal-io/Pulser: Release v0.15.3. \u0026#32; Zenodo.\u0026#32;Retrieved from\u0026#32; https://github.com/pasqal-io/Pulser Pasqal (n.d.) Pasqal,\u0026#32; P. \u0026#32; (n.d.). \u0026#32; QAOA and QAA to solve a QUBO problem. \u0026#32;Retrieved from\u0026#32; https://pulser.readthedocs.io/en/stable/tutorials/qubo.html Herbert (n.d.) Herbert,\u0026#32; S. \u0026#32; (n.d.). \u0026#32; Quantum Computing (CST Part II) Lecture 15: Adiabatic Quantum Computing. \u0026#32;Retrieved from\u0026#32; https://www.cl.cam.ac.uk/teaching/1920/QuantComp/Quantum_Computing_Lecture_15.pdf Childs (n.d.) Childs,\u0026#32; A. \u0026#32; (n.d.). \u0026#32; Quantum algorithms (CO 781, Winter 2008): LECTURE 18: The quantum adiabatic theorem. \u0026#32;Retrieved from\u0026#32; https://www.cs.umd.edu/~amchilds/teaching/w08/l18.pdf Pesah (n.d.) Pesah,\u0026#32; A. \u0026#32; (n.d.). \u0026#32; Adiabatic Quantum Computing. \u0026#32;Retrieved from\u0026#32; https://arthurpesah.me/assets/pdf/introduction-quantum-annealing.pdf ","permalink":"https://gopal-dahale.github.io/ILearnQuantum/posts/mis/qaa/","summary":"Recently, I participated in the The Blaise Pascal [re]Generative Quantum Challenge by Pasqal and got to learn about Pasqal\u0026rsquo;s neutral atom arrays and pulse-level programming as well as implementing quantum algorithms on an analog device. Here, I will share my learnings and in this blog particularly, we will solve the MIS problem with the quantum adiabatic algorithm using Pulser ( Citation: Henrique,\u0026#32;Grijalva \u0026amp; al.,\u0026#32; Henrique,\u0026#32; S.,\u0026#32; Grijalva,\u0026#32; S.,\u0026#32; Henriet,\u0026#32; L.,\u0026#32; Cornillot,\u0026#32; A.","title":"Maximum Independent Set with Quantum Adiabatic Algorithm"},{"content":"A Womanium Global Media Project Initiative\nOverview Previously, we discussed the theoritical aspects of Quantum Collision Finding and the BHT algorithm. We now try to implement in the BHT algorithm using Qiskit for small functions. We\u0026rsquo;ll create a class for this and explain it step-by-step. First let\u0026rsquo;s import essential packages.\nimport numpy as np from qiskit import QuantumCircuit from qiskit.primitives import Sampler from qiskit.tools.visualization import plot_histogram from qiskit.algorithms.algorithm_result import AlgorithmResult from qiskit.providers.ibmq import IBMQ from qiskit.providers.aer import AerSimulator from qiskit_ibm_runtime import QiskitRuntimeService, Session, Options from qiskit_ibm_runtime import Sampler as RuntimeSampler from qiskit_aer.noise import NoiseModel from qiskit.algorithms.algorithm_result import AlgorithmResult seed = 42 np.random.seed(seed) Implementation The BHT class below implements the BHT algorithm. The class takes a Qiskit Sampler object sampler, the n-bit hash function fn and the input size n. Most of the algorithm is present in the solve function of the class.\nclass BHT: def __init__(self, sampler, fn, n): \u0026#34;\u0026#34;\u0026#34; Initialize the BHT algorithm class Args: sampler (Sampler): Qiskit\u0026#39;s Sampler Object fn (np.ndarray): Function whose collisions we want to find represented by a numpy array. n (int): Maximum length of a input/output \u0026#34;\u0026#34;\u0026#34; self.n = n self.fn = fn self.N = 2**n # Total number of inputs (Domain) self.sampler = sampler def _search(self, x, F_x): \u0026#34;\u0026#34;\u0026#34; Check whether there exists x_0 ∈ K so that (x_0, F(x)) ∈ L but x != x_0. Since L is sorted by hashes we use binary search on L. Args: x (int): Input x y (int): Value of the function evaluated at x Returns: index (int): Returns the index of x_0 if found, else -1 \u0026#34;\u0026#34;\u0026#34; low = 0 high = self.k - 1 while low \u0026lt;= high: mid = (low + high) // 2 x0 = self.L[mid][0] if (F_x == self.L[mid][1]) and (x != x0): return x0 elif self.L[mid][1] \u0026lt; F_x: low = mid + 1 else: high = mid - 1 return -1 def _H_mat(self): \u0026#34;\u0026#34;\u0026#34; Creates a unitary matrix for H: X -\u0026gt; {0, 1} Returns: qc (Gate): Gate representing the H matrix \u0026#34;\u0026#34;\u0026#34; size = 2**self.n # Since |X| = n, we need n+1 qubits U = np.zeros((size, size)) # Initialize the matrix for x in range(size): y = self.fn[x] # Compute the function of x x0 = self._search(x, y) if x0 == -1: U[x][x] = 1 else: U[x][x] = -1 # Phase flip if such x0 exists qc = QuantumCircuit(self.n) qc.unitary(U, range(self.n)) oracle = qc.to_gate() oracle.name = \u0026#39;U$_\\omega$\u0026#39; return oracle def _diffuser(self, nqubits): \u0026#34;\u0026#34;\u0026#34; Diffuser for Grover\u0026#39;s algorithm Returns: U_s (Gate): Diffuser circuit. \u0026#34;\u0026#34;\u0026#34; qc = QuantumCircuit(nqubits) for qubit in range(nqubits): qc.h(qubit) for qubit in range(nqubits): qc.x(qubit) qc.h(nqubits - 1) qc.mct(list(range(nqubits - 1)), nqubits - 1) # multi-controlled-toffoli qc.h(nqubits - 1) for qubit in range(nqubits): qc.x(qubit) for qubit in range(nqubits): qc.h(qubit) U_s = qc.to_gate() U_s.name = \u0026#34;U$_s$\u0026#34; return U_s def construct_circuit(self): \u0026#34;\u0026#34;\u0026#34; Construction of the Grover\u0026#39;s circuit. Returns: qc (QuantumCircuit): Grover\u0026#39;s circuit. \u0026#34;\u0026#34;\u0026#34; qc = QuantumCircuit(self.n, self.n) qc.h(range(self.n)) qc.barrier() oracle = self._H_mat() # Oracle H of Grover(H,1) self.num_iterations = int(np.sqrt(self.N / self.k)) for i in range(self.num_iterations): qc.append(oracle, range(self.n)) qc.append(self._diffuser(self.n), range(self.n)) qc.barrier() qc.measure(range(self.n), range(self.n)) return qc def find_collisions(self, x): \u0026#34;\u0026#34;\u0026#34; Finds collisions from the result of Grover\u0026#39;s circuit execution. Returns: collisions (List[tuple]): A list of three element tuple (a, b, c) such that fn[a] = f[b] = c. \u0026#34;\u0026#34;\u0026#34; collisions = [] for i in x: y = self.fn[i] x0 = self._search(i, y) if x0 != -1: collisions.append((x0, i, y)) return collisions def solve(self): \u0026#34;\u0026#34;\u0026#34; Performs the BHT algorithm. Returns: collisions (List[tuple]): A list of three element tuple (a, b, c) such that fn[a] = f[b] = c. \u0026#34;\u0026#34;\u0026#34; X = range(self.N) # Domain of function # Step 1.1: # Start by selecting an arbitrary subset K ⊆ X of cardinality k = 2^(n/3). self.k = int(np.ceil(np.cbrt(self.N))) K = np.random.choice(X, self.k, replace=False) # Create a table L where each item in L holds a unique pair # (x, F(x)) with x ∈ K self.L = [(i, self.fn[i]) for i in K] # Step 1.2: Sort L according to the second entry in each item of L. self.L.sort(key=lambda x: x[1]) # Step 1.3: # Verify whether L contains any collisions, meaning check if there # are distinct elements (x_0, F(x_0)), (x_1, F(x_1)) ∈ L # such that F(x_0) = F(x_1). collisions = [] result = AlgorithmResult() flag = False for i in range(1, self.k): if self.L[i - 1][1] == self.L[i][1]: # Hashes are equal print(\u0026#34;Collision Found\u0026#34;) collisions.append( (self.L[i - 1][0], self.L[i][0], self.L[i][1])) flag = True break if flag == True: # If so, proceed to Step 2.3: # Output the collision set {x_0, x_1}. result.collisions = collisions result.classical = True return result # If not, the 2^(n/3) pairs of L are stored in qRAM. # Construct the circuit for the Grover\u0026#39;s algorithm qc = self.construct_circuit() # Step 2.1: Calculate x1 = Grover(H, 1) # Note that since multiple collisions exists # x1 denotes one such solution # but after executing the circuit we can get # more than one x1. job = self.sampler.run(qc) res = job.result() quasi_dist = res.quasi_dists[0] probs = quasi_dist.binary_probabilities() probs = dict(sorted(probs.items(), reverse=True, key=lambda i: i[1])) prob_keys = list(probs.keys()) x = [int(i, 2) for i in prob_keys] # Step 2.2: Search (x0, F(x1)) ∈ L collisions = self.find_collisions(x) # Step 2.3: Output the collision set {x_0, x_1} result.iterations = self.num_iterations result.probs = probs result.circuit = qc result.collisions = collisions result.classical = False return result We also define a solve_classical function which classically compute the collisions for the given function fn.\ndef solve_classical(fn): \u0026#34;\u0026#34;\u0026#34; Classically computes the collisions in the function `fn`. Args: fn (np.ndarray): Function whose collisions we want to find represented by a numpy array. Returns: collisions (List[tuple]): A list of three element tuple (a, b, c) such that fn[a] = f[b] = c. \u0026#34;\u0026#34;\u0026#34; unique_elements, inverse, counts = np.unique(fn, return_inverse=True, return_counts=True) duplicate_indices = np.where(counts \u0026gt; 1)[0] collisions = [] for idx in duplicate_indices: indices = np.where(inverse == idx)[0] for i, j in zip(indices[:-1], indices[1:]): collisions.append((i, j, unique_elements[idx])) return collisions Ideal Simulation We now test the BHT algorithm with a 5-bit function i.e. n = 5.\nn = 5 # Maximum length of a input/output N = 2**n # Total number of inputs (Domain) X = range(N) # Domain of hash function # Function func = np.array([np.random.randint(low=0, high=N) for i in X]) func array([ 6, 19, 28, 14, 10, 7, 28, 20, 6, 25, 18, 22, 10, 10, 23, 20, 3, 7, 23, 2, 21, 20, 1, 23, 11, 29, 5, 1, 31, 27, 20, 0]) First we try to find the collisions classically.\ncollisions = solve_classical(func) collisions [(22, 27, 1), (0, 8, 6), (5, 17, 7), (4, 12, 10), (12, 13, 10), (7, 15, 20), (15, 21, 20), (21, 30, 20), (14, 18, 23), (18, 23, 23), (2, 6, 28)] Now we use the BHT algorithm to find collisions in the function.\nnp.random.seed(seed) sampler = Sampler() bht = BHT(sampler, func, n) result = bht.solve() # Find collisions print(result) { 'circuit': \u0026lt;qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x7f45ca965580\u0026gt;, 'classical': False, 'collisions': [(17, 5, 7), (15, 21, 20), (15, 7, 20), (15, 30, 20)], 'iterations': 2, 'probs': { '00000': 0.001953125, '00001': 0.001953125, '00010': 0.001953125, '00011': 0.001953125, '00100': 0.001953125, '00101': 0.2363281249999989, '00110': 0.001953125, '00111': 0.2363281249999988, '01000': 0.001953125, '01001': 0.001953125, '01010': 0.001953125, '01011': 0.001953125, '01100': 0.001953125, '01101': 0.001953125, '01110': 0.001953125, '01111': 0.001953125, '10000': 0.001953125, '10001': 0.001953125, '10010': 0.001953125, '10011': 0.001953125, '10100': 0.001953125, '10101': 0.2363281249999989, '10110': 0.001953125, '10111': 0.001953125, '11000': 0.001953125, '11001': 0.001953125, '11010': 0.001953125, '11011': 0.001953125, '11100': 0.001953125, '11101': 0.001953125, '11110': 0.2363281249999988, '11111': 0.001953125}} We can see that the algorithm halted successfully and below is the quantum circuit used for finding the collisions. We can see that it uses 2 iterations of the Grover\u0026rsquo;s algorithm.\nresult.circuit.draw(\u0026#39;mpl\u0026#39;) From the histogram, we can see that there are 4 collisions.\nplot_histogram(result.probs, figsize=(20, 8)) result.collisions [(17, 5, 7), (15, 21, 20), (15, 7, 20), (15, 30, 20)] Hurray! We can observe that the collisions found by the BHT algorithm are also present in the classical solutions.\nNoisy Simulation Now we test the algorithm with a noisy simulator. The noisy simulator is based on the ibmq_manila device.\nservice = QiskitRuntimeService(channel=\u0026#34;ibm_quantum\u0026#34;) backend = service.backend(\u0026#34;ibmq_qasm_simulator\u0026#34;) provider = IBMQ.load_account() real_backend = provider.get_backend(\u0026#39;ibmq_manila\u0026#39;) backend_sim = AerSimulator.from_backend(real_backend) noise_model = NoiseModel.from_backend(backend_sim) # Set options to include the noise model options = Options() options.simulator = { \u0026#34;noise_model\u0026#34;: noise_model, \u0026#34;basis_gates\u0026#34;: backend.configuration().basis_gates, \u0026#34;coupling_map\u0026#34;: backend.configuration().coupling_map, \u0026#34;seed_simulator\u0026#34;: seed } # Set number of shots, optimization_level and resilience_level options.execution.shots = 1000 options.optimization_level = 0 options.resilience_level = 0 np.random.seed(seed) with Session(backend=backend, max_time=\u0026#34;1h\u0026#34;): rt_sampler = RuntimeSampler(backend=backend, options=options) bht = BHT(rt_sampler, func, n) noisy_result = bht.solve() print(noisy_result) { 'circuit': \u0026lt;qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x7f45c0d0f430\u0026gt;, 'classical': False, 'collisions': [(15, 21, 20), (15, 30, 20), (17, 5, 7), (15, 7, 20)], 'iterations': 2, 'probs': { '00000': 0.003, '00001': 0.014, '00010': 0.002, '00011': 0.009, '00100': 0.019, '00101': 0.195, '00110': 0.013, '00111': 0.187, '01000': 0.003, '01010': 0.001, '01011': 0.002, '01100': 0.003, '01101': 0.006, '01110': 0.011, '01111': 0.003, '10000': 0.003, '10001': 0.021, '10010': 0.002, '10011': 0.002, '10100': 0.019, '10101': 0.21, '10110': 0.011, '10111': 0.009, '11000': 0.003, '11001': 0.002, '11010': 0.02, '11011': 0.001, '11100': 0.013, '11101': 0.004, '11110': 0.204, '11111': 0.005}} plot_histogram([result.probs, noisy_result.probs], legend=[\u0026#39;ideal\u0026#39;, \u0026#39;noisy\u0026#39;], figsize=(20, 8)) noisy_result.collisions [(15, 21, 20), (15, 30, 20), (17, 5, 7), (15, 7, 20)] From the histogram, we can observe that the counts for the 4 collisions are slightly decreased but still prominent and the collisions found by the BHT algorithm are still present in the classical solutions.\n","permalink":"https://gopal-dahale.github.io/ILearnQuantum/posts/bht/bht_qiskit/","summary":"A Womanium Global Media Project Initiative\nOverview Previously, we discussed the theoritical aspects of Quantum Collision Finding and the BHT algorithm. We now try to implement in the BHT algorithm using Qiskit for small functions. We\u0026rsquo;ll create a class for this and explain it step-by-step. First let\u0026rsquo;s import essential packages.\nimport numpy as np from qiskit import QuantumCircuit from qiskit.primitives import Sampler from qiskit.tools.visualization import plot_histogram from qiskit.algorithms.algorithm_result import AlgorithmResult from qiskit.","title":"Brassard-Høyer-Tapp Algorithm in Qiskit"},{"content":"A Womanium Global Media Project Initiative.\nCollisions in hash functions A collision in a hash function is when two different inputs produce the same output hash. This is a problem because it violates the fundamental premise of a hash function, which is to produce a unique output for each unique input. Collisions can be exploited by attackers to create fraudulent transactions or gain unauthorized access to secure systems, making them a critical concern in the design and implementation of hash functions.\nTo avoid collisions, hash functions use complex mathematical algorithms to ensure that each input produces a unique output. The quality of a hash function is typically measured by its collision resistance, which refers to its ability to prevent collisions from occurring. Strong collision resistance is important for the security of systems that rely on hash functions, such as digital signatures and cryptographic hash functions used in encryption.\nThe BHT Algorithm The BHT algorithm ( Citation: Brassard,\u0026#32;Hoyer \u0026amp; al.,\u0026#32; Brassard,\u0026#32; G.,\u0026#32; Hoyer,\u0026#32; P.\u0026#32;\u0026amp;\u0026#32;Tapp,\u0026#32; A. \u0026#32; (n.d.). \u0026#32; Quantum Algorithm for the Collision Problem. ) is a generic quantum collision-finding algorithm developed by Brassard, Høyer, and Tapp. The goal is to find a collision of a random function $F : \\{ 0, 1 \\}^n \\rightarrow \\{0, 1\\}^n$.\nGrover\u0026rsquo;s Algorithm and Generalization Given a function $F: X \\rightarrow \\{0,1\\}$ such that there exists a unique $x_0 \\in X$ so that $F(x_0) = 1$. The task is to find $x_0$. We know that this requires $O(\\sqrt{N})$ evaluations of $F$ where, $N = |X|$ ( Citation: Grover,\u0026#32; Grover,\u0026#32; L. \u0026#32; (n.d.). \u0026#32; A fast quantum mechanical algorithm for database search. ) .\nTo generalize this, consider an arbitrary function $F: X \\rightarrow Y$. Now, given some $y_0 \\in Y$, find $x \\in X$ such that $F(x) = y_0$ provided such $x$ exists. If there are $t$ number of solutions i.e. there are $t$ number of such $x$, then it requires $O(\\sqrt{N/t})$ evaluations of $F$. From now onwards, we denote this generalization by Grover($F, y_0$). This will be handy later.\nWhat is qRAM? qRAM is a quantum analogue of RAM which allows to efficiently access stored data in quantum superpositions.\nLet there be a list of classical data $L = \\{ x_0, x_1 \\dots x_{2^m -1} \\}$ where $x_i\\in \\{0,1\\}^n$ for each $i$. Then, the qRAM for $L$ is modeled as an unitary operator $U_{\\text{qRAM}}(L)$ defined by\n$$ \\begin{equation} U_{\\text{qRAM}}(L): \\ket{i} \\otimes \\ket{y} \\rightarrow \\ket{i} \\otimes \\ket{y \\oplus x_i} \\end{equation} $$\nfor $i\\in \\{0,1\\}^m$ and $y\\in \\{0,1\\}^n $.\nIn this context, having qRAM available means that we have a quantum gate capable of realizing the unitary operation (1) for a list $L$ of classical data in addition to access to basic quantum gates ( Citation: Hosoyamada\u0026#32;\u0026amp;\u0026#32;Sasaki,\u0026#32; Hosoyamada,\u0026#32; A.\u0026#32;\u0026amp;\u0026#32;Sasaki,\u0026#32; Y. \u0026#32; (n.d.). \u0026#32; Finding Hash Collisions with Quantum Computers by Using Differential Trails with Smaller Probability than Birthday Bound. ) .\nBHT Algorithm The algorithm consists of 2 steps\nStep 1\nStart by selecting an arbitrary subset $K \\subseteq X$ of cardinality $k = 2^{n/3}$. Create a table $L$ where each item in $L$ holds a unique pair $(x, F (x))$ with $x \\in K$. Sort $L$ according to the second entry in each item of $L$. Verify whether $L$ contains any collisions, meaning check if there are distinct elements $(x_0, F (x_0)), (x_1, F (x_1)) \\in L$ such that $F (x_0) = F (x_1)$. If so, proceed to Step 2.3. If not, the $2^{n/3}$ pairs of $L$ are stored in qRAM. The implication is that they can be accessed in quantum superposition. Step 2\nCalculate $x_1 = \\textbf{Grover}(H, 1)$ where $H : X \\rightarrow {0, 1}$ denotes the function defined by $H(x) = 1$ iff there exists $x_0 \\in K$ such that $(x_0 , F (x)) \\in L$ but $x \\not = x_0$. (It\u0026rsquo;s worth noting that if such $x_0$ exists, it is unique, as we have already verified the absence of collisions in $L$). Search $(x_0 , F (x_1 )) \\in L$. Output the collision set $\\{x_0 , x_1 \\}$. Collision Complexity For the BHT algorithm, the step 1 involves making queries in time $O(2^{n/3})$. Step 2 uses Grover\u0026rsquo;s search and runs in $O\\left(\\sqrt{2^n/|L|}\\right) = O(2^{n/3})$. Therefore, BHT finds a collision in time $\\tilde{O}(2^{n/3})$ by making $O(2^{n/3})$ quantum queries, provided that there is access to exponentially large quantum random access memory (qRAM).\nClassical Setting In the classical setting, the generic attack complexity to find collisions against an n-bit hash function is $O(2^{n/2})$ due to the birthday paradox. As a result, any dedicated attack that finds collisions with less than $O(2^{n/2})$ complexity is considered as a meaningful attack.\nQuantum Setting In the quantum setting, the complexity of a generic attack depends on the specific assumptions or model of the underlying quantum machines. Regardless of the model, the lower bound of the query complexity is proven to be $\\Omega(2^{n/3})$ ( Citation: Zhandry,\u0026#32; Zhandry,\u0026#32; M. \u0026#32; (n.d.). \u0026#32; A Note on the Quantum Collision and Set Equality Problems. ) and there is an attack matching this bound if $O(2^{n/3})$ qubits are available which is the BHT algorithm. By the same analogy, any dedicated attack with less than $O(2^{n/3})$ quantum complexity should be regarded as a meaningful attack. However, comparing dedicated attacks with the generic attack complexity in the quantum setting requires careful consideration because the generic attack complexity depends on the model of the quantum computations. We\u0026rsquo;ll see this in the next sections.\nImpact of qRAM on BHT We consider a model of a small quantum computer of polynomial size and a qRAM that allows us to access exponentially many classical data in quantum superposition. Here we do $\\textbf{not}$ consider any parallelized computations. In this model, the best collision-finding algorithm is BHT because we can implement it with qRAM (of size $O(2^{n/3})$) and its time complexity matches the tight quantum query complexity $\\Theta (2^{n/3} )$.\nTime and memory tradeoff compared to classical algorithms BHT achieves a time complexity $\\tilde{O}(2^{n/3})$, however, it requires a large qRAM of size $\\tilde{O}(2^{n/3} )$ as well. This raises concerns since the availability of such qRAM in the future is uncertain, especially in the case of small quantum computers.\nAlternatively, one can use a quantum circuit of size $O(2^{n/3})$, but it comes with the trade-off of using an exponentially large number of qubits. This leads to questions about parallelization. In terms of time-space complexity, BHT is less efficient than the classical parallel rho method ( Citation: Bernstein,\u0026#32; Bernstein,\u0026#32; D. \u0026#32; (n.d.). \u0026#32; Cost analysis of hash collisions: Will quantum computers make SHARCS obsolete. ) ( Citation: Oorschot\u0026#32;\u0026amp;\u0026#32;Wiener,\u0026#32; Oorschot,\u0026#32; P.\u0026#32;\u0026amp;\u0026#32;Wiener,\u0026#32; M. \u0026#32; (n.d.). \u0026#32; Parallel collision search with application to hash functions and discrete logarithms. ) . When $P$ classical processors are available, the parallel rho method finds a collision in time $O(2^{n/2}/P)$. This means that if a quantum computer of size $2^{n/3}$ is available, but qRAM is not, simply running the parallel rho method on the quantum computer can find a collision in time $2^{n/6}$ which is much faster than BHT.\nIn the classical setting, the rho method finds a memory-less collision in time $O(2^{n/2})$, which matches the classical tight bound for query complexity. However, there is no known any $\\textbf{memory-less}$ quantum collision finding algorithm that matches the optimal query complexity $2^{n/3}$.\nLet $S$ denote the size of computational resources required for a quantum algoithm and $S$ is the maximum size of quantum computers and classical memory. Let $T$ denote its time complexity. Then the trade-off $T \\cdot S = 2^{n/2}$ given by the parallel rho method is the best one even in the quantum setting.\nOutlook In the quantum setting, comparing dedicated attacks with the generic attack complexity requires caution since the generic attack complexity depends on the model of the quantum computations. As we have seen, the BHT cannot outperform the classical computations, considering that each qubit can behave as either processor or memory (by running $2^{n/3}$ processors in parallel, collisions can be found in time $O(2^{n/6})$ even with classical machines). However, if a quantum computer of polynomial size with exponentially large qRAM is available, BHT is the best collision attack. It is challenging to predict which model is more likely to be realized in the future, and it would be valuable to discuss the advantages of attacks in various models with different generic attack complexities.\nReferences Bernstein (n.d.) Bernstein,\u0026#32; D. \u0026#32; (n.d.). \u0026#32; Cost analysis of hash collisions: Will quantum computers make SHARCS obsolete. Brassard,\u0026#32; Hoyer\u0026#32;\u0026amp;\u0026#32;Tapp (n.d.) Brassard,\u0026#32; G.,\u0026#32; Hoyer,\u0026#32; P.\u0026#32;\u0026amp;\u0026#32;Tapp,\u0026#32; A. \u0026#32; (n.d.). \u0026#32; Quantum Algorithm for the Collision Problem. Hosoyamada\u0026#32;\u0026amp;\u0026#32;Sasaki (n.d.) Hosoyamada,\u0026#32; A.\u0026#32;\u0026amp;\u0026#32;Sasaki,\u0026#32; Y. \u0026#32; (n.d.). \u0026#32; Finding Hash Collisions with Quantum Computers by Using Differential Trails with Smaller Probability than Birthday Bound. Grover (n.d.) Grover,\u0026#32; L. \u0026#32; (n.d.). \u0026#32; A fast quantum mechanical algorithm for database search. Oorschot\u0026#32;\u0026amp;\u0026#32;Wiener (n.d.) Oorschot,\u0026#32; P.\u0026#32;\u0026amp;\u0026#32;Wiener,\u0026#32; M. \u0026#32; (n.d.). \u0026#32; Parallel collision search with application to hash functions and discrete logarithms. Zhandry (n.d.) Zhandry,\u0026#32; M. \u0026#32; (n.d.). \u0026#32; A Note on the Quantum Collision and Set Equality Problems. ","permalink":"https://gopal-dahale.github.io/ILearnQuantum/posts/bht/quantum_collision_finding/","summary":"A Womanium Global Media Project Initiative.\nCollisions in hash functions A collision in a hash function is when two different inputs produce the same output hash. This is a problem because it violates the fundamental premise of a hash function, which is to produce a unique output for each unique input. Collisions can be exploited by attackers to create fraudulent transactions or gain unauthorized access to secure systems, making them a critical concern in the design and implementation of hash functions.","title":"Quantum Collision Finding"},{"content":"Paper: ( Citation: Mao,\u0026#32;Chaudhary \u0026amp; al.,\u0026#32;2022 Mao,\u0026#32; Y.,\u0026#32; Chaudhary,\u0026#32; M.,\u0026#32; Kondappan,\u0026#32; M.,\u0026#32; Shi,\u0026#32; J.,\u0026#32; Ilo-Okeke,\u0026#32; E.,\u0026#32; Ivannikov,\u0026#32; V.\u0026#32;\u0026amp;\u0026#32;Byrnes,\u0026#32; T. \u0026#32; (2022). \u0026#32; Deterministic measurement-based imaginary time evolution. https://doi.org/0.48550/arXiv.2202.09100 ) Imaginary time evolution (ITE) ITE is a technique to find the ground state of a system where the time t is replaced by imagainary time $i\\tau$. To understand this, let us consider the time-dependent Schrodinger equation for a system with Hamiltonian $H$:\n$$ \\begin{equation} i\\frac{\\partial}{\\partial t} \\ket{\\psi(t)}= H \\ket{\\psi(t)} \\end{equation} $$\nwhere $ \\ket{\\psi(t)} $ is is the state of the system at time $t$, and $H$ is the Hamiltonian of the system. In the case of real time evolutoin, the state of the system at time $t$ is given by $ \\ket{\\psi(t)} = e^{-iHt}\\ket{\\psi(0)}$ where $\\ket{\\psi(0)}$ is the initial state of the system.\nIn the case of imaginary time evolution, the modified Schrodinger equation is given by:\n$$ \\frac{\\partial}{\\partial \\tau}\\ket{\\psi(\\tau)} = -H\\ket{\\psi(\\tau)} $$\nThe solution to this equation is given by $ \\ket{\\psi(\\tau)} = e^{-H\\tau}\\ket{\\psi(\\tau)} $,\nThis transfomration makes it easier to find the ground state of the system. As $\\tau \\rightarrow \\infty$, the state of the system converges to the ground state of the system. $$ \\begin{equation} \\lim_{\\tau \\rightarrow \\infty} \\ket{\\psi(\\tau)} = \\ket{E_0} \\end{equation} $$ where $\\vert E_0\\rangle$ is the ground state of $H$.\nTheory Measurement operators The strategy is to construct measurement operators which take the form of the exponentiated hamiltonian in equation 2. This can be achieved by performing a weak measurement of $H$. Consider a n-qubit system with an ancilla qubit a which will be used for the weak measurement via the hamiltonian of $H \\otimes Y$. The ancilla qubit is initially prepared in state $\\ket{+}$. Performing time evolution for $\\epsilon$ time we have:\n$$ \\begin{align*} e^{-i \\epsilon H \\otimes Y} \\ket{\\psi(0)} \\ket{+}_a =\u0026amp; \\sum_n \\bra{E_n}\\ket{\\psi_0} \\ket{E_n} e^{-i \\epsilon E_n Y} \\ket{+}_a \\\\ =\u0026amp; \\frac{1}{\\sqrt{2}}\\sum_n \\bra{E_n}\\ket{\\psi_0} \\ket{E_n} \\Bigl[ (\\cos E_n \\epsilon - \\sin E_n \\epsilon)\\ket{0}_a \\\\ \u0026amp; (\\cos E_n \\epsilon + \\sin E_n \\epsilon)\\ket{1}_a \\Bigr] \\end{align*} $$\nUsing the projector operator $\\ket{0}\\bra{0}$ on the ancilla qubit, we get\n$$ \\begin{equation} \\frac{1}{\\sqrt{2}}\\sum_n \\bra{E_n}\\ket{\\psi_0} (\\cos E_n \\epsilon - \\sin E_n \\epsilon)\\ket{E_n}\\ket{0}_a \\approx \\frac{e^{-\\epsilon H}}{\\sqrt{2}} \\ket{\\psi_0}\\ket{0} \\end{equation} $$\nwhile $\\ket{1}\\bra{1}$ gives\n$$ \\begin{equation} \\frac{1}{\\sqrt{2}}\\sum_n \\bra{E_n}\\ket{\\psi_0} (\\cos E_n \\epsilon + \\sin E_n \\epsilon)\\ket{E_n}\\ket{1}_a \\approx \\frac{e^{\\epsilon H}}{\\sqrt{2}} \\ket{\\psi_0}\\ket{0} \\end{equation} $$\nSo the measurement operators are\n$$ \\begin{align} M_0 =\u0026amp; \\frac{1}{\\sqrt{2}}\\sum_n (\\cos E_n \\epsilon - \\sin E_n \\epsilon)\\ket{E_n}\\bra{E_n} \\approx \\frac{e^{-\\epsilon H}}{\\sqrt{2}} \\\\ M_1 =\u0026amp; \\frac{1}{\\sqrt{2}}\\sum_n (\\cos E_n \\epsilon + \\sin E_n \\epsilon)\\ket{E_n}\\bra{E_n} \\approx \\frac{e^{\\epsilon H}}{\\sqrt{2}} \\end{align} $$\nWe can see that the above two equations takes the form of the exponentiated operator in equation 2. The exponential approximation is valid when $||\\epsilon H|| \\ll 1$.\nAmplification of ground state Upon measurement of the ancilla qubit we get can a 0 or 1. Consider a particular measurement sequence where there are $k_0$ counts of 0 (i.e. $M_0$ is the measurement operator) and $k_1$ counts of 1 (i.e. $M_1$ is the measurement operator. Since $[M_0, M_1] = 0$, the order of outcomes does not matter and therefore we can write\n$$ \\begin{equation} M_0^{k_0}M_1^{k_1} = \\sum_nA_{k_0k_1}(\\epsilon E_n) \\bra{E_n}\\ket{\\psi_0}\\ket{E_n} \\end{equation} $$\nwhere the amplitude function is defined as\n$$ \\begin{equation} A_{k_0k_1} = \\frac{(\\cos x - \\sin x)^{k0}(\\cos x - \\sin x)^{k_1}}{\\sqrt{2^{k_0 + k_1}}} \\end{equation} $$\nThe amplitude function takes a gaussian form for large number of measurements in the range $-\\pi/4 \\leq x \\leq \\pi/4$ and the peak occurs at\n$$ \\begin{equation} x_{k_0k_1}^{max} = \\frac{1}{2}\\arcsin \\left( \\frac{k_0 - k_1}{k_0 + k_1} \\right) \\end{equation} $$\nFor large measurements a collapse of energy basis occurs and the ground state energy can be estimated from $x_{k_0k_1}^{max} \\approx \\epsilon E_0$, we can approximate the equation \\ref{eq:seq} to $e^{-\\epsilon(k_0 - k_1)H}$ from the exponential approximation of the equations \\ref{eq:m0} and \\ref{eq:m1}. From the figure we can see that this exponential approximates only one side of the gaussian and therefore for random outcomes of $k_0, k_1$, the sequence may not result in amplification of ground state. If the gaussian peak are to the left of ground state, the measurements sequence will produce the desired value of $A_{k_0k_1}$ which will enhance the ground state. To be precise, if $x_{k_0k_1}^{max} \u0026lt; \\epsilon (E_0 + E_1)/2$ for any outcome of measurement, then it will have an amplifying effect towards the ground state.\nMethodology The strategy is the adjust the peak position of the gaussian near the ground state. The idea is to apply unitary operations conditioned on the measuremnet outcomes. Using a energy threshold $E_{th}$, if the peak is below the threshold then no operation is applied otherwise a corrective unitary is applied. This is peformed iteratively:\n$$ \\begin{equation} \\ket{\\psi_{t+1}} = \\frac{U_{k_0^{(t+1)}k_1^{(t+1)}}M_n\\ket{\\psi_t}}{\\sqrt{\\bra{{\\psi_t}}|{M_n^{\\dag}M_n}\\ket{\\psi_t}}} \\end{equation} $$\nwhere $n\\in {0,1}$ and\n$$ \\begin{equation} U_{k_0k_1} = \\begin{cases} I \u0026amp;\\quad\\text{if} ~ x_{k_0k_1}^{max} \u0026lt; \\epsilon E_{th} \\\\ U_c \u0026amp;\\quad\\text{otherwise.} \\ \\end{cases} \\end{equation} $$\nand $$ \\begin{equation} k_m^{(t+1)} = \\begin{cases} k_m^{(t)} + \\delta_{mn} \u0026amp;\\quad\\text{if} ~ x_{(k_0^{(t)} + \\delta_{0n})(k_0^{(t)} + \\delta_{1n})}^{max} \u0026lt; \\epsilon E_{th} \\\\ 0 \u0026amp;\\quad\\text{otherwise.} \\ \\end{cases} \\end{equation} $$\nFor ensuring the convergence over iterations to the ground state, $|\\bra{E_n}U_c\\ket{E_m}| \u0026gt; 0, \\forall n,m$ which can be satisfied with a random unitary matrix. The authors considered random intial states and corrective unitary, however a sophisticated choice of initial state and corrective unitary can be made to improve the convergence rate. The code explains the examples shown in the paper in detail.\nReferences Mao,\u0026#32; Chaudhary,\u0026#32; Kondappan,\u0026#32; Shi,\u0026#32; Ilo-Okeke,\u0026#32; Ivannikov\u0026#32;\u0026amp;\u0026#32;Byrnes (2022) Mao,\u0026#32; Y.,\u0026#32; Chaudhary,\u0026#32; M.,\u0026#32; Kondappan,\u0026#32; M.,\u0026#32; Shi,\u0026#32; J.,\u0026#32; Ilo-Okeke,\u0026#32; E.,\u0026#32; Ivannikov,\u0026#32; V.\u0026#32;\u0026amp;\u0026#32;Byrnes,\u0026#32; T. \u0026#32; (2022). \u0026#32; Deterministic measurement-based imaginary time evolution. https://doi.org/0.48550/arXiv.2202.09100 ","permalink":"https://gopal-dahale.github.io/ILearnQuantum/posts/dmbite/dmbite/","summary":"Paper: ( Citation: Mao,\u0026#32;Chaudhary \u0026amp; al.,\u0026#32;2022 Mao,\u0026#32; Y.,\u0026#32; Chaudhary,\u0026#32; M.,\u0026#32; Kondappan,\u0026#32; M.,\u0026#32; Shi,\u0026#32; J.,\u0026#32; Ilo-Okeke,\u0026#32; E.,\u0026#32; Ivannikov,\u0026#32; V.\u0026#32;\u0026amp;\u0026#32;Byrnes,\u0026#32; T. \u0026#32; (2022). \u0026#32; Deterministic measurement-based imaginary time evolution. https://doi.org/0.48550/arXiv.2202.09100 ) Imaginary time evolution (ITE) ITE is a technique to find the ground state of a system where the time t is replaced by imagainary time $i\\tau$. To understand this, let us consider the time-dependent Schrodinger equation for a system with Hamiltonian $H$:","title":"Deterministic Measurement-based imaginary time evolution"}]