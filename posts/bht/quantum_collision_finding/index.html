<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Quantum Collision Finding | ILearnQuantum</title>
<meta name="keywords" content="Womanium">
<meta name="description" content="A Womanium Global Media Project Initiative.
Collisions in hash functions A collision in a hash function is when two different inputs produce the same output hash. This is a problem because it violates the fundamental premise of a hash function, which is to produce a unique output for each unique input. Collisions can be exploited by attackers to create fraudulent transactions or gain unauthorized access to secure systems, making them a critical concern in the design and implementation of hash functions.">
<meta name="author" content="Gopal Ramesh Dahale">
<link rel="canonical" href="https://gopal-dahale.github.io/ILearnQuantum/posts/bht/quantum_collision_finding/">
<link crossorigin="anonymous" href="/ILearnQuantum/assets/css/stylesheet.4fd967528ad5a75f3ce961dbda94c03a4739e156197539fdac72973ab0f932e0.css" integrity="sha256-T9lnUorVp1886WHb2pTAOkc54VYZdTn9rHKXOrD5MuA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/ILearnQuantum/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://gopal-dahale.github.io/ILearnQuantum/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://gopal-dahale.github.io/ILearnQuantum/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://gopal-dahale.github.io/ILearnQuantum/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://gopal-dahale.github.io/ILearnQuantum/apple-touch-icon.png">
<link rel="mask-icon" href="https://gopal-dahale.github.io/ILearnQuantum/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9LHHHMGS3N"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-9LHHHMGS3N', { 'anonymize_ip': false });
}
</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
onload="renderMathInElement(document.body,
        {
              delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false},
              ],
              throwOnError : false
          });"></script>



<link rel="stylesheet" type="text/css" href="/ILearnQuantum/hugo-cite.css" />
<meta property="og:title" content="Quantum Collision Finding" />
<meta property="og:description" content="A Womanium Global Media Project Initiative.
Collisions in hash functions A collision in a hash function is when two different inputs produce the same output hash. This is a problem because it violates the fundamental premise of a hash function, which is to produce a unique output for each unique input. Collisions can be exploited by attackers to create fraudulent transactions or gain unauthorized access to secure systems, making them a critical concern in the design and implementation of hash functions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://gopal-dahale.github.io/ILearnQuantum/posts/bht/quantum_collision_finding/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-21T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2023-07-21T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Quantum Collision Finding"/>
<meta name="twitter:description" content="A Womanium Global Media Project Initiative.
Collisions in hash functions A collision in a hash function is when two different inputs produce the same output hash. This is a problem because it violates the fundamental premise of a hash function, which is to produce a unique output for each unique input. Collisions can be exploited by attackers to create fraudulent transactions or gain unauthorized access to secure systems, making them a critical concern in the design and implementation of hash functions."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://gopal-dahale.github.io/ILearnQuantum/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Quantum Collision Finding",
      "item": "https://gopal-dahale.github.io/ILearnQuantum/posts/bht/quantum_collision_finding/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Quantum Collision Finding",
  "name": "Quantum Collision Finding",
  "description": "A Womanium Global Media Project Initiative.\nCollisions in hash functions A collision in a hash function is when two different inputs produce the same output hash. This is a problem because it violates the fundamental premise of a hash function, which is to produce a unique output for each unique input. Collisions can be exploited by attackers to create fraudulent transactions or gain unauthorized access to secure systems, making them a critical concern in the design and implementation of hash functions.",
  "keywords": [
    "Womanium"
  ],
  "articleBody": "A Womanium Global Media Project Initiative.\nCollisions in hash functions A collision in a hash function is when two different inputs produce the same output hash. This is a problem because it violates the fundamental premise of a hash function, which is to produce a unique output for each unique input. Collisions can be exploited by attackers to create fraudulent transactions or gain unauthorized access to secure systems, making them a critical concern in the design and implementation of hash functions.\nTo avoid collisions, hash functions use complex mathematical algorithms to ensure that each input produces a unique output. The quality of a hash function is typically measured by its collision resistance, which refers to its ability to prevent collisions from occurring. Strong collision resistance is important for the security of systems that rely on hash functions, such as digital signatures and cryptographic hash functions used in encryption.\nThe BHT Algorithm The BHT algorithm ( Citation: Brassard, Hoyer \u0026 al., Brassard, G., Hoyer, P. \u0026 Tapp, A. (n.d.). Quantum Algorithm for the Collision Problem. ) is a generic quantum collision-finding algorithm developed by Brassard, Høyer, and Tapp. The goal is to find a collision of a random function $F : \\{ 0, 1 \\}^n \\rightarrow \\{0, 1\\}^n$.\nGrover’s Algorithm and Generalization Given a function $F: X \\rightarrow \\{0,1\\}$ such that there exists a unique $x_0 \\in X$ so that $F(x_0) = 1$. The task is to find $x_0$. We know that this requires $O(\\sqrt{N})$ evaluations of $F$ where, $N = |X|$ ( Citation: Grover, Grover, L. (n.d.). A fast quantum mechanical algorithm for database search. ) .\nTo generalize this, consider an arbitrary function $F: X \\rightarrow Y$. Now, given some $y_0 \\in Y$, find $x \\in X$ such that $F(x) = y_0$ provided such $x$ exists. If there are $t$ number of solutions i.e. there are $t$ number of such $x$, then it requires $O(\\sqrt{N/t})$ evaluations of $F$. From now onwards, we denote this generalization by Grover($F, y_0$). This will be handy later.\nWhat is qRAM? qRAM is a quantum analogue of RAM which allows to efficiently access stored data in quantum superpositions.\nLet there be a list of classical data $L = \\{ x_0, x_1 \\dots x_{2^m -1} \\}$ where $x_i\\in \\{0,1\\}^n$ for each $i$. Then, the qRAM for $L$ is modeled as an unitary operator $U_{\\text{qRAM}}(L)$ defined by\n$$ \\begin{equation} U_{\\text{qRAM}}(L): \\ket{i} \\otimes \\ket{y} \\rightarrow \\ket{i} \\otimes \\ket{y \\oplus x_i} \\end{equation} $$\nfor $i\\in \\{0,1\\}^m$ and $y\\in \\{0,1\\}^n $.\nIn this context, having qRAM available means that we have a quantum gate capable of realizing the unitary operation (1) for a list $L$ of classical data in addition to access to basic quantum gates ( Citation: Hosoyamada \u0026 Sasaki, Hosoyamada, A. \u0026 Sasaki, Y. (n.d.). Finding Hash Collisions with Quantum Computers by Using Differential Trails with Smaller Probability than Birthday Bound. ) .\nBHT Algorithm The algorithm consists of 2 steps\nStep 1\nStart by selecting an arbitrary subset $K \\subseteq X$ of cardinality $k = 2^{n/3}$. Create a table $L$ where each item in $L$ holds a unique pair $(x, F (x))$ with $x \\in K$. Sort $L$ according to the second entry in each item of $L$. Verify whether $L$ contains any collisions, meaning check if there are distinct elements $(x_0, F (x_0)), (x_1, F (x_1)) \\in L$ such that $F (x_0) = F (x_1)$. If so, proceed to Step 2.3. If not, the $2^{n/3}$ pairs of $L$ are stored in qRAM. The implication is that they can be accessed in quantum superposition. Step 2\nCalculate $x_1 = \\textbf{Grover}(H, 1)$ where $H : X \\rightarrow {0, 1}$ denotes the function defined by $H(x) = 1$ iff there exists $x_0 \\in K$ such that $(x_0 , F (x)) \\in L$ but $x \\not = x_0$. (It’s worth noting that if such $x_0$ exists, it is unique, as we have already verified the absence of collisions in $L$). Search $(x_0 , F (x_1 )) \\in L$. Output the collision set $\\{x_0 , x_1 \\}$. Collision Complexity For the BHT algorithm, the step 1 involves making queries in time $O(2^{n/3})$. Step 2 uses Grover’s search and runs in $O\\left(\\sqrt{2^n/|L|}\\right) = O(2^{n/3})$. Therefore, BHT finds a collision in time $\\tilde{O}(2^{n/3})$ by making $O(2^{n/3})$ quantum queries, provided that there is access to exponentially large quantum random access memory (qRAM).\nClassical Setting In the classical setting, the generic attack complexity to find collisions against an n-bit hash function is $O(2^{n/2})$ due to the birthday paradox. As a result, any dedicated attack that finds collisions with less than $O(2^{n/2})$ complexity is considered as a meaningful attack.\nQuantum Setting In the quantum setting, the complexity of a generic attack depends on the specific assumptions or model of the underlying quantum machines. Regardless of the model, the lower bound of the query complexity is proven to be $\\Omega(2^{n/3})$ ( Citation: Zhandry, Zhandry, M. (n.d.). A Note on the Quantum Collision and Set Equality Problems. ) and there is an attack matching this bound if $O(2^{n/3})$ qubits are available which is the BHT algorithm. By the same analogy, any dedicated attack with less than $O(2^{n/3})$ quantum complexity should be regarded as a meaningful attack. However, comparing dedicated attacks with the generic attack complexity in the quantum setting requires careful consideration because the generic attack complexity depends on the model of the quantum computations. We’ll see this in the next sections.\nImpact of qRAM on BHT We consider a model of a small quantum computer of polynomial size and a qRAM that allows us to access exponentially many classical data in quantum superposition. Here we do $\\textbf{not}$ consider any parallelized computations. In this model, the best collision-finding algorithm is BHT because we can implement it with qRAM (of size $O(2^{n/3})$) and its time complexity matches the tight quantum query complexity $\\Theta (2^{n/3} )$.\nTime and memory tradeoff compared to classical algorithms BHT achieves a time complexity $\\tilde{O}(2^{n/3})$, however, it requires a large qRAM of size $\\tilde{O}(2^{n/3} )$ as well. This raises concerns since the availability of such qRAM in the future is uncertain, especially in the case of small quantum computers.\nAlternatively, one can use a quantum circuit of size $O(2^{n/3})$, but it comes with the trade-off of using an exponentially large number of qubits. This leads to questions about parallelization. In terms of time-space complexity, BHT is less efficient than the classical parallel rho method ( Citation: Bernstein, Bernstein, D. (n.d.). Cost analysis of hash collisions: Will quantum computers make SHARCS obsolete. ) ( Citation: Oorschot \u0026 Wiener, Oorschot, P. \u0026 Wiener, M. (n.d.). Parallel collision search with application to hash functions and discrete logarithms. ) . When $P$ classical processors are available, the parallel rho method finds a collision in time $O(2^{n/2}/P)$. This means that if a quantum computer of size $2^{n/3}$ is available, but qRAM is not, simply running the parallel rho method on the quantum computer can find a collision in time $2^{n/6}$ which is much faster than BHT.\nIn the classical setting, the rho method finds a memory-less collision in time $O(2^{n/2})$, which matches the classical tight bound for query complexity. However, there is no known any $\\textbf{memory-less}$ quantum collision finding algorithm that matches the optimal query complexity $2^{n/3}$.\nLet $S$ denote the size of computational resources required for a quantum algoithm and $S$ is the maximum size of quantum computers and classical memory. Let $T$ denote its time complexity. Then the trade-off $T \\cdot S = 2^{n/2}$ given by the parallel rho method is the best one even in the quantum setting.\nOutlook In the quantum setting, comparing dedicated attacks with the generic attack complexity requires caution since the generic attack complexity depends on the model of the quantum computations. As we have seen, the BHT cannot outperform the classical computations, considering that each qubit can behave as either processor or memory (by running $2^{n/3}$ processors in parallel, collisions can be found in time $O(2^{n/6})$ even with classical machines). However, if a quantum computer of polynomial size with exponentially large qRAM is available, BHT is the best collision attack. It is challenging to predict which model is more likely to be realized in the future, and it would be valuable to discuss the advantages of attacks in various models with different generic attack complexities.\nReferences Bernstein (n.d.) Bernstein, D. (n.d.). Cost analysis of hash collisions: Will quantum computers make SHARCS obsolete. Brassard, Hoyer \u0026 Tapp (n.d.) Brassard, G., Hoyer, P. \u0026 Tapp, A. (n.d.). Quantum Algorithm for the Collision Problem. Hosoyamada \u0026 Sasaki (n.d.) Hosoyamada, A. \u0026 Sasaki, Y. (n.d.). Finding Hash Collisions with Quantum Computers by Using Differential Trails with Smaller Probability than Birthday Bound. Grover (n.d.) Grover, L. (n.d.). A fast quantum mechanical algorithm for database search. Oorschot \u0026 Wiener (n.d.) Oorschot, P. \u0026 Wiener, M. (n.d.). Parallel collision search with application to hash functions and discrete logarithms. Zhandry (n.d.) Zhandry, M. (n.d.). A Note on the Quantum Collision and Set Equality Problems. ",
  "wordCount" : "1486",
  "inLanguage": "en",
  "datePublished": "2023-07-21T00:00:00Z",
  "dateModified": "2023-07-21T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Gopal Ramesh Dahale"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://gopal-dahale.github.io/ILearnQuantum/posts/bht/quantum_collision_finding/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ILearnQuantum",
    "logo": {
      "@type": "ImageObject",
      "url": "https://gopal-dahale.github.io/ILearnQuantum/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://gopal-dahale.github.io/ILearnQuantum/" accesskey="h" title="ILearnQuantum (Alt + H)">ILearnQuantum</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://gopal-dahale.github.io/ILearnQuantum/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://gopal-dahale.github.io/ILearnQuantum/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://gopal-dahale.github.io/ILearnQuantum/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://gopal-dahale.github.io/ILearnQuantum/">Home</a>&nbsp;»&nbsp;<a href="https://gopal-dahale.github.io/ILearnQuantum/posts/">Posts</a></div>
    <h1 class="post-title">
      Quantum Collision Finding
    </h1>
    <div class="post-meta"><span title='2023-07-21 00:00:00 +0000 UTC'>July 21, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Gopal Ramesh Dahale

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#collisions-in-hash-functions" aria-label="Collisions in hash functions">Collisions in hash functions</a></li>
                <li>
                    <a href="#the-bht-algorithm" aria-label="The BHT Algorithm">The BHT Algorithm</a><ul>
                        
                <li>
                    <a href="#grovers-algorithm-and-generalization" aria-label="Grover&amp;rsquo;s Algorithm and Generalization">Grover&rsquo;s Algorithm and Generalization</a></li>
                <li>
                    <a href="#what-is-qram" aria-label="What is qRAM?">What is qRAM?</a></li>
                <li>
                    <a href="#bht-algorithm" aria-label="BHT Algorithm">BHT Algorithm</a></li></ul>
                </li>
                <li>
                    <a href="#collision-complexity" aria-label="Collision Complexity">Collision Complexity</a><ul>
                        
                <li>
                    <a href="#classical-setting" aria-label="Classical Setting">Classical Setting</a></li>
                <li>
                    <a href="#quantum-setting" aria-label="Quantum Setting">Quantum Setting</a></li></ul>
                </li>
                <li>
                    <a href="#impact-of-qram-on-bht" aria-label="Impact of qRAM on BHT">Impact of qRAM on BHT</a></li>
                <li>
                    <a href="#time-and-memory-tradeoff-compared-to-classical-algorithms" aria-label="Time and memory tradeoff compared to classical algorithms">Time and memory tradeoff compared to classical algorithms</a></li>
                <li>
                    <a href="#outlook" aria-label="Outlook">Outlook</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>A Womanium Global Media Project Initiative.</p>
<h2 id="collisions-in-hash-functions">Collisions in hash functions<a hidden class="anchor" aria-hidden="true" href="#collisions-in-hash-functions">#</a></h2>
<p>A collision in a hash function is when two different inputs produce the same output hash. This is a problem because it violates the fundamental premise of a hash function, which is to produce a unique output for each unique input. Collisions can be exploited by attackers to create fraudulent transactions or gain unauthorized access to secure systems, making them a critical concern in the design and implementation of hash functions.</p>
<p>To avoid collisions, hash functions use complex mathematical algorithms to ensure that each input produces a unique output. The quality of a hash function is typically measured by its collision resistance, which refers to its ability to prevent collisions from occurring. Strong collision resistance is important for the security of systems that rely on hash functions, such as digital signatures and cryptographic hash functions used in encryption.</p>
<h2 id="the-bht-algorithm">The BHT Algorithm<a hidden class="anchor" aria-hidden="true" href="#the-bht-algorithm">#</a></h2>
<p>The BHT algorithm 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="#bht"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Gilles"><span itemprop="familyName">Brassard</span></span>,&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Peter"><span itemprop="familyName">Hoyer</span></span>
                  <em>&amp; al.</em>,&#32;</a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/CreativeWork"
      data-type="default"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Brassard</span>,&#32;
    <meta itemprop="givenName" content="Gilles" />
    G.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Hoyer</span>,&#32;
    <meta itemprop="givenName" content="Peter" />
    P.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Tapp</span>,&#32;
    <meta itemprop="givenName" content="Alain" />
    A.</span>
  &#32;
  (n.d.).
  &#32;<span itemprop="name">
    <i>Quantum Algorithm for the Collision Problem</i></span>.
  </span>

</span></span>)</span>
 is a generic quantum collision-finding algorithm developed by Brassard, Høyer, and Tapp. The goal is to find a collision of a random function $F : \{ 0, 1 \}^n \rightarrow  \{0, 1\}^n$.</p>
<h3 id="grovers-algorithm-and-generalization">Grover&rsquo;s Algorithm and Generalization<a hidden class="anchor" aria-hidden="true" href="#grovers-algorithm-and-generalization">#</a></h3>
<p>Given a function $F: X \rightarrow \{0,1\}$ such that there exists a unique $x_0 \in X$ so that $F(x_0) = 1$. The task is to find $x_0$. We know that this requires $O(\sqrt{N})$ evaluations of $F$ where, $N = |X|$ 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="#grover"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Lov K."><span itemprop="familyName">Grover</span></span>,&#32;</a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/CreativeWork"
      data-type="default"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Grover</span>,&#32;
    <meta itemprop="givenName" content="Lov K." />
    L.</span>
  &#32;
  (n.d.).
  &#32;<span itemprop="name">
    <i>A fast quantum mechanical algorithm for database search</i></span>.
  </span>

</span></span>)</span>
.</p>
<p>To generalize this, consider an arbitrary function $F: X \rightarrow Y$. Now, given some $y_0 \in Y$, find $x \in X$ such that $F(x) = y_0$ provided such $x$ exists. If there are $t$ number of solutions i.e. there are $t$ number of such $x$, then it requires $O(\sqrt{N/t})$ evaluations of $F$. From now onwards, we denote this generalization by <strong>Grover</strong>($F, y_0$). This will be handy later.</p>
<h3 id="what-is-qram">What is qRAM?<a hidden class="anchor" aria-hidden="true" href="#what-is-qram">#</a></h3>
<p>qRAM is a quantum analogue of RAM which allows to efficiently access stored data in quantum superpositions.</p>
<p>Let there be a list of classical data $L = \{ x_0, x_1 \dots x_{2^m -1} \}$ where $x_i\in \{0,1\}^n$ for each $i$. Then, the qRAM for $L$ is modeled as an unitary operator $U_{\text{qRAM}}(L)$ defined by</p>
<p>$$
\begin{equation}
U_{\text{qRAM}}(L): \ket{i} \otimes \ket{y} \rightarrow \ket{i} \otimes \ket{y \oplus x_i}
\end{equation}
$$</p>
<p>for $i\in \{0,1\}^m$ and $y\in \{0,1\}^n $.</p>
<p>In this context, having qRAM available means that we have a quantum gate capable of realizing the unitary operation (1) for a list $L$ of classical data in addition to access to basic quantum gates 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="#collision"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Akinori"><span itemprop="familyName">Hosoyamada</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Yu"><span itemprop="familyName">Sasaki</span></span>,&#32;</a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/CreativeWork"
      data-type="default"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Hosoyamada</span>,&#32;
    <meta itemprop="givenName" content="Akinori" />
    A.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Sasaki</span>,&#32;
    <meta itemprop="givenName" content="Yu" />
    Y.</span>
  &#32;
  (n.d.).
  &#32;<span itemprop="name">
    <i>Finding Hash Collisions with Quantum Computers by Using Differential Trails with Smaller Probability than Birthday Bound</i></span>.
  </span>

</span></span>)</span>
.</p>
<h3 id="bht-algorithm">BHT Algorithm<a hidden class="anchor" aria-hidden="true" href="#bht-algorithm">#</a></h3>
<p>The algorithm consists of 2 steps</p>
<p><strong>Step 1</strong></p>
<ol>
<li>Start by selecting an arbitrary subset $K \subseteq X$ of cardinality $k = 2^{n/3}$. Create a table $L$ where each item in $L$ holds a unique pair $(x, F (x))$ with $x \in K$.</li>
<li>Sort $L$ according to the second entry in each item of $L$.</li>
<li>Verify whether $L$ contains any collisions, meaning check if there are distinct elements $(x_0, F (x_0)), (x_1, F (x_1)) \in L$ such that $F (x_0) = F (x_1)$. If so, proceed to Step 2.3. If not, the $2^{n/3}$ pairs of $L$ are stored in <strong>qRAM</strong>. The implication is that they can be accessed in quantum superposition.</li>
</ol>
<p><strong>Step 2</strong></p>
<ol>
<li>Calculate $x_1 = \textbf{Grover}(H, 1)$ where $H : X \rightarrow {0, 1}$ denotes the function defined by $H(x) = 1$ iff there exists $x_0 \in K$ such that $(x_0 , F (x)) \in L$ but $x \not = x_0$. (It&rsquo;s worth noting that if such $x_0$ exists, it is unique, as we have already verified the absence of collisions in $L$).</li>
<li>Search $(x_0 , F (x_1 )) \in L$.</li>
<li>Output the collision set $\{x_0 , x_1 \}$.</li>
</ol>
<h2 id="collision-complexity">Collision Complexity<a hidden class="anchor" aria-hidden="true" href="#collision-complexity">#</a></h2>
<p>For the BHT algorithm, the step 1 involves making queries in time $O(2^{n/3})$. Step 2 uses Grover&rsquo;s search and runs in $O\left(\sqrt{2^n/|L|}\right) = O(2^{n/3})$. Therefore, BHT finds a collision in time $\tilde{O}(2^{n/3})$ by making $O(2^{n/3})$ quantum queries, provided that there is access to exponentially large quantum random access memory (qRAM).</p>
<h3 id="classical-setting">Classical Setting<a hidden class="anchor" aria-hidden="true" href="#classical-setting">#</a></h3>
<p>In the classical setting, the generic attack complexity to find collisions against an n-bit hash function is $O(2^{n/2})$ due to the birthday paradox. As a result, any dedicated attack that finds collisions with less than $O(2^{n/2})$ complexity is considered as a meaningful attack.</p>
<h3 id="quantum-setting">Quantum Setting<a hidden class="anchor" aria-hidden="true" href="#quantum-setting">#</a></h3>
<p>In the quantum setting, the complexity of a generic attack depends on the specific assumptions or model of the underlying quantum machines. Regardless of the model, the lower bound of the query complexity is proven to be $\Omega(2^{n/3})$ 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="#zhandry"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Mark"><span itemprop="familyName">Zhandry</span></span>,&#32;</a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/CreativeWork"
      data-type="default"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Zhandry</span>,&#32;
    <meta itemprop="givenName" content="Mark" />
    M.</span>
  &#32;
  (n.d.).
  &#32;<span itemprop="name">
    <i>A Note on the Quantum Collision and Set Equality Problems</i></span>.
  </span>

</span></span>)</span>
 and there is an attack matching this bound if $O(2^{n/3})$ qubits are available which is the BHT algorithm. By the same analogy, any dedicated attack with less than $O(2^{n/3})$ quantum complexity should be regarded as a meaningful attack. However, comparing dedicated attacks with the generic attack complexity in the quantum setting requires careful consideration because the generic attack complexity depends on the model of the quantum computations. We&rsquo;ll see this in the next sections.</p>
<h2 id="impact-of-qram-on-bht">Impact of qRAM on BHT<a hidden class="anchor" aria-hidden="true" href="#impact-of-qram-on-bht">#</a></h2>
<p>We consider a model of a small quantum computer of polynomial size and a qRAM that allows us to access exponentially many classical data in quantum superposition. Here we do $\textbf{not}$ consider any parallelized computations. In this model, the best collision-finding algorithm is BHT because we can implement it with qRAM (of size $O(2^{n/3})$) and its time complexity matches the tight quantum query complexity $\Theta (2^{n/3} )$.</p>
<h2 id="time-and-memory-tradeoff-compared-to-classical-algorithms">Time and memory tradeoff compared to classical algorithms<a hidden class="anchor" aria-hidden="true" href="#time-and-memory-tradeoff-compared-to-classical-algorithms">#</a></h2>
<p>BHT achieves a time complexity $\tilde{O}(2^{n/3})$, however, it requires a large qRAM of size $\tilde{O}(2^{n/3} )$ as well. This raises concerns since the availability of such qRAM in the future is uncertain, especially in the case of small quantum computers.</p>
<p>Alternatively, one can use a quantum circuit of size $O(2^{n/3})$, but it comes with the trade-off of using an exponentially large number of qubits. This leads to questions about parallelization. In terms of time-space complexity, BHT is less efficient than the classical parallel rho method 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="#bernstein"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Daniel"><span itemprop="familyName">Bernstein</span></span>,&#32;</a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/CreativeWork"
      data-type="default"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Bernstein</span>,&#32;
    <meta itemprop="givenName" content="Daniel" />
    D.</span>
  &#32;
  (n.d.).
  &#32;<span itemprop="name">
    <i>Cost analysis of hash collisions: Will quantum computers make SHARCS obsolete</i></span>.
  </span>

</span></span>)</span>
 
 
 
 
 
 <span class="hugo-cite-intext"
         itemprop="citation">(<span class="hugo-cite-group">
 
           <a href="#prho"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Paul C. van"><span itemprop="familyName">Oorschot</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Michael J."><span itemprop="familyName">Wiener</span></span>,&#32;</a><span class="hugo-cite-citation"> 
 
 
 
 
 
 
 
 
 
 
 <span itemscope
       itemtype="https://schema.org/CreativeWork"
       data-type="default"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Oorschot</span>,&#32;
     <meta itemprop="givenName" content="Paul C. van" />
     P.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Wiener</span>,&#32;
     <meta itemprop="givenName" content="Michael J." />
     M.</span>
   &#32;
   (n.d.).
   &#32;<span itemprop="name">
     <i>Parallel collision search with application to hash functions and discrete logarithms</i></span>.
   </span>
 
 </span></span>)</span>
. When $P$ classical processors are available, the parallel rho method finds a collision in time $O(2^{n/2}/P)$. This means that if a quantum computer of size $2^{n/3}$ is available, but qRAM is not, simply running the parallel rho method on the quantum computer can find a collision in time $2^{n/6}$ which is much faster than BHT.</p>
<p>In the classical setting, the rho method finds a memory-less collision in time $O(2^{n/2})$, which matches the classical tight bound for query complexity. However, there is no known any $\textbf{memory-less}$ quantum collision finding algorithm that matches the optimal query complexity $2^{n/3}$.</p>
<p>Let $S$ denote the size of computational resources required for a quantum algoithm and $S$ is the maximum size of quantum computers and classical memory. Let $T$ denote its time complexity. Then the trade-off $T \cdot S = 2^{n/2}$ given by the parallel rho
method is the best one even in the quantum setting.</p>
<h2 id="outlook">Outlook<a hidden class="anchor" aria-hidden="true" href="#outlook">#</a></h2>
<p>In the quantum setting, comparing dedicated attacks with the generic attack complexity requires caution since the generic attack complexity depends on the model of the quantum computations. As we have seen, the BHT cannot outperform the classical computations, considering that each qubit can behave as either processor or memory (by running $2^{n/3}$ processors in parallel, collisions can be found in time $O(2^{n/6})$ even with classical machines). However, if a quantum computer of polynomial size with exponentially large qRAM is available, BHT is the best collision attack. It is challenging to predict which model is more likely to be realized in the future, and it would be valuable to discuss the advantages of attacks in various models with different generic attack complexities.</p>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>

  

  










<section class="hugo-cite-bibliography">
  <dl>
    

      <div id="bernstein">
        <dt>
          Bernstein

          
          (n.d.)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/CreativeWork"
      data-type="default"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Bernstein</span>,&#32;
    <meta itemprop="givenName" content="Daniel" />
    D.</span>
  &#32;
  (n.d.).
  &#32;<span itemprop="name">
    <i>Cost analysis of hash collisions: Will quantum computers make SHARCS obsolete</i></span>.
  </span>

</dd>

      </div>

      <div id="bht">
        <dt>
          Brassard,&#32;
          Hoyer&#32;&amp;&#32;Tapp

          
          (n.d.)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/CreativeWork"
      data-type="default"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Brassard</span>,&#32;
    <meta itemprop="givenName" content="Gilles" />
    G.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Hoyer</span>,&#32;
    <meta itemprop="givenName" content="Peter" />
    P.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Tapp</span>,&#32;
    <meta itemprop="givenName" content="Alain" />
    A.</span>
  &#32;
  (n.d.).
  &#32;<span itemprop="name">
    <i>Quantum Algorithm for the Collision Problem</i></span>.
  </span>

</dd>

      </div>

      <div id="collision">
        <dt>
          Hosoyamada&#32;&amp;&#32;Sasaki

          
          (n.d.)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/CreativeWork"
      data-type="default"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Hosoyamada</span>,&#32;
    <meta itemprop="givenName" content="Akinori" />
    A.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Sasaki</span>,&#32;
    <meta itemprop="givenName" content="Yu" />
    Y.</span>
  &#32;
  (n.d.).
  &#32;<span itemprop="name">
    <i>Finding Hash Collisions with Quantum Computers by Using Differential Trails with Smaller Probability than Birthday Bound</i></span>.
  </span>

</dd>

      </div>

      <div id="grover">
        <dt>
          Grover

          
          (n.d.)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/CreativeWork"
      data-type="default"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Grover</span>,&#32;
    <meta itemprop="givenName" content="Lov K." />
    L.</span>
  &#32;
  (n.d.).
  &#32;<span itemprop="name">
    <i>A fast quantum mechanical algorithm for database search</i></span>.
  </span>

</dd>

      </div>

      <div id="prho">
        <dt>
          Oorschot&#32;&amp;&#32;Wiener

          
          (n.d.)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/CreativeWork"
      data-type="default"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Oorschot</span>,&#32;
    <meta itemprop="givenName" content="Paul C. van" />
    P.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Wiener</span>,&#32;
    <meta itemprop="givenName" content="Michael J." />
    M.</span>
  &#32;
  (n.d.).
  &#32;<span itemprop="name">
    <i>Parallel collision search with application to hash functions and discrete logarithms</i></span>.
  </span>

</dd>

      </div>

      <div id="zhandry">
        <dt>
          Zhandry

          
          (n.d.)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/CreativeWork"
      data-type="default"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Zhandry</span>,&#32;
    <meta itemprop="givenName" content="Mark" />
    M.</span>
  &#32;
  (n.d.).
  &#32;<span itemprop="name">
    <i>A Note on the Quantum Collision and Set Equality Problems</i></span>.
  </span>

</dd>

      </div>
  </dl>
</section>





  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://gopal-dahale.github.io/ILearnQuantum/tags/womanium/">Womanium</a></li>
    </ul>
  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ilearnquantum" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://gopal-dahale.github.io/ILearnQuantum/">ILearnQuantum</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
